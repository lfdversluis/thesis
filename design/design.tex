\chapter{Design \& Implementation}



With the recent addition of the MultiChain there are three distinct database files with three distinct database managers present in the Tribler code base.
None these database managers are fully documented or tested.
A proper solution is to merge these three databases files into a single database, controlled by a single database manager.
This will result in less code to maintain, all logic in one place and easier to cover with proper unit tests and documentation.
Ideally this database manager should handle all communication to and from the database in an asynchronous, non-blocking manner.
This will yield increased stability and speed, improved maintainability and enhances the productivity of developers.

\subsection{A new framework}
Storm was chosen but why... explained here..

Tribler has Twisted integration, we would like to have a manager that supports Twisted...
First mention of Twisted in Dispersy: \url{https://github.com/Tribler/tribler/issues/129} but was never done.
Until now.


\section{StormDBManager}

\begin{figure}[h]
	\makebox[\textwidth][c]{\includegraphics[width=\linewidth]{experimentation/diagrams/storm_db_worker.png}}
	\caption{An overview of the queueing mechanism of StormDBManager.}
	\label{fig:storm_db_worker}
\end{figure}

StormDBManager features a complete asynchronous and non-blocking interface to handle database access.
It is developed using the Storm database framework which is developed by Canonical and featured in several other products such as Launchpad \cite{canonical2011storm}.
Storm allows for both an old-fashioned database approach using direct SQL statements or to use it as an object-relational mapper (ORM).
Currently, Storm supports three databases: SQLite, MySQL and PostgreSQL.
As Dispersy makes use of a SQLite3 database, this was a necessity.
Additionally, the Storm database framework has integrated support for Twisted and is available on the official repositories of Ubuntu and Debian, making it a good fit for Tribler.
Because Storm also features ORM support, this database manager can be the foundation for an ORM based approach.

Since multi-threaded support is severely limited using SQLite3, we decided to leverage the Twisted thread-pool to allocate a thread for a longer period of time to run a worker on.
This worked will be owned by the StormDBManager.
Using this approach, all database operations happen on the same thread but outside the Twisted main thread, guaranteeing I/O does not block it.
The system works as follows, visualized in Figure~\ref{fig:storm_db_worker}.
Fist, a Dispersy function calls the StormDBManager (1).
The StormDBManager generates a deferred and returns this to the caller (2).
Next, the StormDBManager queues a tuple of four elements (3):

\begin{enumerate}
	\item The function to be called, e.g. execute or fetchone.
	\item The arguments to be passed to the function.
	\item The keyword arguments to be passed to the function.
	\item A deferred to handle the response in an asynchronous way.
\end{enumerate}

Note that by using a thread-safe queue, all calls are scheduled in the same order as required, ensuring serialized behaviour.
The worker running on the thread waits blocking for new items to come, preventing the thread from dying.
Once it a tuple is available it fetches it (4).
It then executes the function (5) and calls the deferred's callback with the result (6).
After that, the worker proceeds to wait blocking for a new item, or executes the next tuple if present.
To make sure the worker can still commit or release the thread, two predetermined values can be queued upon which the worker will commit or shut down, respectively.

Explanation

Architecture...

implementation...